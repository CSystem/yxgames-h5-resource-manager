"use strict";
const ts = require("typescript");
const fs = require("fs");
function findDecorator(fileName) {
    let sourceFile = ts.createSourceFile(fileName, fs.readFileSync(fileName).toString(), ts.ScriptTarget.ES5, true);
    let result = [];
    delintNode(sourceFile);
    return result;
    function delintNode(node) {
        switch (node.kind) {
            case ts.SyntaxKind.ClassDeclaration:
                let declaration = node;
                if (declaration.decorators) {
                    let a = declaration.decorators.map(analyzeDecorator);
                    result = result.concat(a);
                }
        }
        ts.forEachChild(node, delintNode);
    }
}
exports.findDecorator = findDecorator;
function analyzeDecorator(decoratorNode) {
    let expression = decoratorNode.expression;
    let index = 0;
    let syntaxList;
    while (index < expression.getChildCount()) {
        let node = expression.getChildAt(index);
        if (node.kind == ts.SyntaxKind.OpenParenToken) {
            syntaxList = expression.getChildAt(index + 1);
            break;
        }
        index++;
    }
    let name = expression.getChildAt(0).getText();
    let generics = [];
    let genericMapper = (generic) => {
        if (generic.kind == ts.SyntaxKind.UnionType) {
            return generic.types.map(t => t.text);
        }
        else {
            throw new Error("error");
        }
    };
    if (expression.typeArguments) {
        generics = expression.typeArguments.map(genericMapper);
    }
    let filter = node => node.kind === ts.SyntaxKind.StringLiteral ||
        node.kind === ts.SyntaxKind.ObjectLiteralExpression ||
        node.kind === ts.SyntaxKind.ArrowFunction ||
        node.kind === ts.SyntaxKind.FunctionExpression;
    let mapper = node => {
        if (node.kind == ts.SyntaxKind.StringLiteral) {
            return node.text;
        }
        else if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {
            let result = node.getText();
            return JSON.parse(result);
        }
        else if (node.kind === ts.SyntaxKind.ArrowFunction || node.kind === ts.SyntaxKind.FunctionExpression) {
            let result = node.getText();
            let func = eval(result);
            return func;
        }
    };
    let paramters = syntaxList.getChildren()
        .filter(filter)
        .map(mapper);
    return {
        name,
        paramters,
        generics
    };
}
