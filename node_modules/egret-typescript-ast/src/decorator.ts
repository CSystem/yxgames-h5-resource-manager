import * as ts from 'typescript';
import * as fs from 'fs';


export interface DecoratorInfo {

    name: string,

    paramters: any[],

    generics: string[]

}

export function findDecorator(fileName: string) {

    let sourceFile = ts.createSourceFile(fileName, fs.readFileSync(fileName).toString(), ts.ScriptTarget.ES5, true);
    let result: DecoratorInfo[] = [];
    delintNode(sourceFile);
    return result;

    function delintNode(node: ts.Node) {
        switch (node.kind) {
            case ts.SyntaxKind.ClassDeclaration:
                let declaration = node as ts.ClassDeclaration;
                if (declaration.decorators) {
                    let a = declaration.decorators.map(analyzeDecorator);
                    result = result.concat(a);
                }

        }
        ts.forEachChild(node, delintNode);
    }
}


function analyzeDecorator(decoratorNode: ts.Decorator) {

    let expression = decoratorNode.expression as ts.CallExpression;
    let index = 0;
    let syntaxList: ts.Node;
    while (index < expression.getChildCount()) {
        let node = expression.getChildAt(index);
        if (node.kind == ts.SyntaxKind.OpenParenToken) {
            syntaxList = expression.getChildAt(index + 1);
            break;
        }
        index++;
    }
    let name = expression.getChildAt(0).getText();
    let generics = [];
    let genericMapper = (generic) => {
        if (generic.kind == ts.SyntaxKind.UnionType) {
            return (generic as ts.UnionType).types.map(t => (t as ts.StringLiteralType).text);
        }
        else {
            throw new Error("error");
        }
    }

    if (expression.typeArguments) {
        generics = expression.typeArguments.map(genericMapper);
    }
    let filter = node =>
        node.kind === ts.SyntaxKind.StringLiteral ||
        node.kind === ts.SyntaxKind.ObjectLiteralExpression ||
        node.kind === ts.SyntaxKind.ArrowFunction ||
        node.kind === ts.SyntaxKind.FunctionExpression;
    let mapper = node => {

        if (node.kind == ts.SyntaxKind.StringLiteral) {
            return (node as ts.StringLiteral).text
        }
        else if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {
            let result = (node as ts.ObjectLiteralExpression).getText()
            return JSON.parse(result)
        }
        else if (node.kind === ts.SyntaxKind.ArrowFunction || node.kind === ts.SyntaxKind.FunctionExpression) {
            let result = (node as ts.ObjectLiteralExpression).getText()
            let func = eval(result);
            return func;
        }
    }

    let paramters = syntaxList.getChildren()
        .filter(filter)
        .map(mapper);

    return {
        name,
        paramters,
        generics
    }
}